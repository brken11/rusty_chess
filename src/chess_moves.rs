use crate::board::pieces;
use pieces::Piece;
use pieces::Color;

#[repr(u8)]
#[derive(Debug)]
pub enum SpecialMoves {
    None,
    Check,
    Checkmate,
    Stalemate,
    Castling,
    CastlingCheck,
    CastlingCheckmate,
    CastlingStalemate,
    Promotion,
    PromotionCheck,
    PromotionCheckmate,
    PromotionStalemate,
    EnPassant,
    EnPassantCheck,
    EnPassantCheckmate,
    EnPassantStalemate,
    EnableEnPassant,
    EnableEnPassantCheck,
    EnableEnPassantCheckmate,
    EnableEnPassantStalemate,
    Capture,
    CaptureCheck,
    CaptureCheckmate,
    CaptureStalemate,
    CapturePromotion,
    CapturePromotionCheck,
    CapturePromotionCheckmate,
    CapturePromotionStalemate,
    //Moves may be generated by the engine ahead of time, so they may need to be properly classified.
    GeneratedOnly,
}

pub enum SpecialMoveType{
    None,
    Castling,
    Promotion,
    EnPassant,
    EnableEnPassant,
}
pub enum SpecialMoveResult{
    None,
    Check,
    Checkmate,
    Stalemate,
}

#[derive(Debug)]
pub struct ChessMove {
    piece: Piece,
    origin: u8,
    target: u8,
    special: SpecialMoves,
}

impl ChessMove {
    pub fn new(piece: Piece, origin: u8, target: u8, special: SpecialMoves) -> ChessMove {
        ChessMove {
            piece,
            origin,
            target,
            special,
        }
    }

    pub fn to_long_algebraic(&self) -> String {
        let algebraic_notation = String::new();

    }
}

pub fn special_move_builder(move_type: SpecialMoveType, result: SpecialMoveResult, captures: bool) -> SpecialMoves {
    match move_type {
        SpecialMoveType::None => build_none_or_promotion(result, captures, SpecialMoves::None, SpecialMoves::Capture),
        SpecialMoveType::Promotion => build_none_or_promotion(result, captures, SpecialMoves::Promotion, SpecialMoves::CapturePromotion),
        SpecialMoveType::Castling => build_move_type(result, SpecialMoves::Castling),
        SpecialMoveType::EnPassant => build_move_type(result, SpecialMoves::EnPassant), // Captures handled intrinsically
        SpecialMoveType::EnableEnPassant => build_move_type(result, SpecialMoves::EnableEnPassant),
    }
}
/// Builds `None`- or promotion-related moves
fn build_none_or_promotion(result: SpecialMoveResult, captures: bool, base: SpecialMoves, capture_base: SpecialMoves) -> SpecialMoves {
    match result {
        SpecialMoveResult::None => if captures { capture_base } else { base },
        SpecialMoveResult::Check => if captures { capture_base.add_check() } else { base.add_check() },
        SpecialMoveResult::Checkmate => if captures { capture_base.add_checkmate() } else { base.add_checkmate() },
        SpecialMoveResult::Stalemate => if captures { capture_base.add_stalemate() } else { base.add_stalemate() },
    }
}

/// Builds moves for types without captures (e.g. `Castling`, `EnPassant`, `EnableEnPassant`)
fn build_move_type(result: SpecialMoveResult, base: SpecialMoves) -> SpecialMoves {
    match result {
        SpecialMoveResult::None => base,
        SpecialMoveResult::Check => base.add_check(),
        SpecialMoveResult::Checkmate => base.add_checkmate(),
        SpecialMoveResult::Stalemate => base.add_stalemate(),
    }
}

/// Helper methods for modifying SpecialMoves
impl SpecialMoves {
    fn add_check(self) -> SpecialMoves {
        match self {
            SpecialMoves::None => SpecialMoves::Check,
            SpecialMoves::Castling => SpecialMoves::CastlingCheck,
            SpecialMoves::Promotion => SpecialMoves::PromotionCheck,
            SpecialMoves::CapturePromotion => SpecialMoves::CapturePromotionCheck,
            SpecialMoves::EnPassant => SpecialMoves::EnPassantCheck,
            SpecialMoves::EnableEnPassant => SpecialMoves::EnableEnPassantCheck,
            _ => unimplemented!("Check variant not handled for {:?}", self),
        }
    }
    fn add_checkmate(self) -> SpecialMoves {
        match self {
            SpecialMoves::None => SpecialMoves::Checkmate,
            SpecialMoves::Castling => SpecialMoves::CastlingCheckmate,
            SpecialMoves::Promotion => SpecialMoves::PromotionCheckmate,
            SpecialMoves::CapturePromotion => SpecialMoves::CapturePromotionCheckmate,
            SpecialMoves::EnPassant => SpecialMoves::EnPassantCheckmate,
            SpecialMoves::EnableEnPassant => SpecialMoves::EnableEnPassantCheckmate,
            _ => unimplemented!("Checkmate variant not handled for {:?}", self),
        }
    }
    fn add_stalemate(self) -> SpecialMoves {
        match self {
            SpecialMoves::None => SpecialMoves::Stalemate,
            SpecialMoves::Castling => SpecialMoves::CastlingStalemate,
            SpecialMoves::Promotion => SpecialMoves::PromotionStalemate,
            SpecialMoves::CapturePromotion => SpecialMoves::CapturePromotionStalemate,
            SpecialMoves::EnPassant => SpecialMoves::EnPassantStalemate,
            SpecialMoves::EnableEnPassant => SpecialMoves::EnableEnPassantStalemate,
            _ => unimplemented!("Stalemate variant not handled for {:?}", self),
        }
    }
}
