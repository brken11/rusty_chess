use crate::board::pieces;
use pieces::Piece;
use pieces::Color;

#[repr(u8)]
#[derive(Debug)]
pub enum SpecialMoves {
    None,
    Check,
    Checkmate,
    Stalemate,
    Castling,
    CastlingCheck,
    CastlingCheckmate,
    CastlingStalemate,
    Promotion,
    PromotionCheck,
    PromotionCheckmate,
    PromotionStalemate,
    EnPassant,
    EnPassantCheck,
    EnPassantCheckmate,
    EnPassantStalemate,
    EnableEnPassant,
    EnableEnPassantCheck,
    EnableEnPassantCheckmate,
    EnableEnPassantStalemate,
    Capture,
    CaptureCheck,
    CaptureCheckmate,
    CaptureStalemate,
    CapturePromotion,
    CapturePromotionCheck,
    CapturePromotionCheckmate,
    CapturePromotionStalemate,
    //Moves may be generated by the engine ahead of time, so they may need to be properly classified.
    GeneratedOnly,
}

pub enum SpecialMoveType{
    None,
    Castling,
    Promotion,
    EnPassant,
    EnableEnPassant,
}
pub enum SpecialMoveResult{
    None,
    Check,
    Checkmate,
    Stalemate,
}

#[derive(Debug)]
pub struct ChessMove {
    piece: Piece,
    origin: u8,
    target: u8,
    special: SpecialMoves,
}

impl ChessMove {
    pub fn new(piece: Piece, origin: u8, target: u8, special: SpecialMoves) -> ChessMove {
        ChessMove {
            piece,
            origin,
            target,
            special,
        }
    }

    pub fn to_long_algebraic(&self) -> String {
        let mut algebraic_notation = String::new();
        let is_promotion = self.special.is_promotion();

        algebraic_notation.push(
        if is_promotion {
                self.piece.to_char()
            } else {
                self.piece.get_color()
                          .get_pawn()
                          .to_char()
            });
        algebraic_notation.push_str(&self.origin.to_string());
        if self.special.is_capture() {
            algebraic_notation.push('x');
        } else{
            algebraic_notation.push('-');
        }
        algebraic_notation.push_str(&self.target.to_string());
        if is_promotion {
            let mut promotion = "=".to_string();
            promotion.push(self.piece.to_char());
            algebraic_notation.push_str(&promotion);
        }
        match self.special.move_result() {
            SpecialMoveResult::None => (),
            SpecialMoveResult::Check => algebraic_notation.push('+'),
            SpecialMoveResult::Checkmate => algebraic_notation.push('#'),
            SpecialMoveResult::Stalemate => algebraic_notation.push('0'),
        }
        algebraic_notation
    }
}

pub fn special_move_builder(move_type: SpecialMoveType, result: SpecialMoveResult, captures: bool) -> SpecialMoves {
    match move_type {
        SpecialMoveType::None => build_none_or_promotion(result, captures, SpecialMoves::None, SpecialMoves::Capture),
        SpecialMoveType::Promotion => build_none_or_promotion(result, captures, SpecialMoves::Promotion, SpecialMoves::CapturePromotion),
        SpecialMoveType::Castling => build_move_type(result, SpecialMoves::Castling),
        SpecialMoveType::EnPassant => build_move_type(result, SpecialMoves::EnPassant), // Captures handled intrinsically
        SpecialMoveType::EnableEnPassant => build_move_type(result, SpecialMoves::EnableEnPassant),
    }
}
/// Builds `None`- or promotion-related moves
fn build_none_or_promotion(result: SpecialMoveResult, captures: bool, base: SpecialMoves, capture_base: SpecialMoves) -> SpecialMoves {
    match result {
        SpecialMoveResult::None => if captures { capture_base } else { base },
        SpecialMoveResult::Check => if captures { capture_base.add_check() } else { base.add_check() },
        SpecialMoveResult::Checkmate => if captures { capture_base.add_checkmate() } else { base.add_checkmate() },
        SpecialMoveResult::Stalemate => if captures { capture_base.add_stalemate() } else { base.add_stalemate() },
    }
}

/// Builds moves for types without captures (e.g. `Castling`, `EnPassant`, `EnableEnPassant`)
fn build_move_type(result: SpecialMoveResult, base: SpecialMoves) -> SpecialMoves {
    match result {
        SpecialMoveResult::None => base,
        SpecialMoveResult::Check => base.add_check(),
        SpecialMoveResult::Checkmate => base.add_checkmate(),
        SpecialMoveResult::Stalemate => base.add_stalemate(),
    }
}

/// Helper methods for modifying SpecialMoves
impl SpecialMoves {
    pub fn is_castle(&self) -> bool {
        match self {
            SpecialMoves::Castling | SpecialMoves::CastlingCheck | SpecialMoves::CastlingCheckmate |
            SpecialMoves::CastlingStalemate => true,
            _ => false,
        }
    }
    pub fn is_promotion(&self) -> bool {
        match self {
            SpecialMoves::Promotion | SpecialMoves::PromotionCheck | SpecialMoves::PromotionCheckmate |
            SpecialMoves::PromotionStalemate | SpecialMoves::CapturePromotion |
            SpecialMoves::CapturePromotionCheck | SpecialMoves::CapturePromotionCheckmate |
            SpecialMoves::CapturePromotionStalemate=> true,
            _ => false,
        }
    }
    pub fn is_check(&self) -> bool {
        match self {
            SpecialMoves::Check | SpecialMoves::CastlingCheck | SpecialMoves::PromotionCheck |
            SpecialMoves::CapturePromotionCheck | SpecialMoves::EnPassantCheck |
            SpecialMoves::EnableEnPassantCheck => true,
            _ => false,
        }
    }
    pub fn is_checkmate(&self) -> bool {
        match self {
            SpecialMoves::Checkmate | SpecialMoves::CastlingCheckmate | SpecialMoves::PromotionCheckmate |
            SpecialMoves::CapturePromotionCheckmate | SpecialMoves::EnPassantCheckmate |
            SpecialMoves::EnableEnPassantCheckmate => true,
            _ => false,
        }
    }
    pub fn is_stalemate(&self) -> bool {
        match self {
            SpecialMoves::Stalemate | SpecialMoves::CastlingStalemate | SpecialMoves::PromotionStalemate |
            SpecialMoves::CapturePromotionStalemate | SpecialMoves::EnPassantStalemate |
            SpecialMoves::EnableEnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_capture(&self) -> bool {
        match self {
            SpecialMoves::Capture | SpecialMoves::CaptureCheck | SpecialMoves::CaptureCheckmate |
            SpecialMoves::CapturePromotion | SpecialMoves::CapturePromotionCheck |
            SpecialMoves::CapturePromotionCheckmate | SpecialMoves::EnPassant | SpecialMoves::EnPassantCheck |
            SpecialMoves::EnPassantCheckmate | SpecialMoves::EnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_en_passant(&self) -> bool {
        match self {
            SpecialMoves::EnPassant | SpecialMoves::EnPassantCheck | SpecialMoves::EnPassantCheckmate |
            SpecialMoves::EnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_enable_en_passant(&self) -> bool {
        match self {
            SpecialMoves::EnableEnPassant | SpecialMoves::EnableEnPassantCheck |
            SpecialMoves::EnableEnPassantCheckmate | SpecialMoves::EnableEnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn move_result(&self) -> SpecialMoveResult {
        match self {
            SpecialMoves::None | SpecialMoves::Castling | SpecialMoves::Promotion |
            SpecialMoves::EnPassant | SpecialMoves::EnableEnPassant |
            SpecialMoves::Capture | SpecialMoves::CapturePromotion =>
                SpecialMoveResult::None,
            SpecialMoves::Check | SpecialMoves::CastlingCheck | SpecialMoves::PromotionCheck |
            SpecialMoves::EnPassantCheck | SpecialMoves::EnableEnPassantCheck |
            SpecialMoves::CaptureCheck | SpecialMoves::CapturePromotionCheck =>
                SpecialMoveResult::Check,
            SpecialMoves::Checkmate | SpecialMoves::CastlingCheckmate | SpecialMoves::PromotionCheckmate |
            SpecialMoves::EnPassantCheckmate | SpecialMoves::EnableEnPassantCheckmate |
            SpecialMoves::CaptureCheckmate | SpecialMoves::CapturePromotionCheckmate=>
                SpecialMoveResult::Checkmate,
            SpecialMoves::Stalemate | SpecialMoves::CastlingStalemate | SpecialMoves::PromotionStalemate |
            SpecialMoves::EnPassantStalemate | SpecialMoves::EnableEnPassantStalemate |
            SpecialMoves::CaptureStalemate | SpecialMoves::CapturePromotionStalemate =>
                SpecialMoveResult::Stalemate,
            SpecialMoves::GeneratedOnly => unimplemented!("GeneratedOnly variant not handled for {:?}", self),
        }
    }
    fn add_check(self) -> SpecialMoves {
        match self {
            SpecialMoves::None => SpecialMoves::Check,
            SpecialMoves::Castling => SpecialMoves::CastlingCheck,
            SpecialMoves::Promotion => SpecialMoves::PromotionCheck,
            SpecialMoves::CapturePromotion => SpecialMoves::CapturePromotionCheck,
            SpecialMoves::EnPassant => SpecialMoves::EnPassantCheck,
            SpecialMoves::EnableEnPassant => SpecialMoves::EnableEnPassantCheck,
            _ => unimplemented!("Check variant not handled for {:?}", self),
        }
    }
    fn add_checkmate(self) -> SpecialMoves {
        match self {
            SpecialMoves::None => SpecialMoves::Checkmate,
            SpecialMoves::Castling => SpecialMoves::CastlingCheckmate,
            SpecialMoves::Promotion => SpecialMoves::PromotionCheckmate,
            SpecialMoves::CapturePromotion => SpecialMoves::CapturePromotionCheckmate,
            SpecialMoves::EnPassant => SpecialMoves::EnPassantCheckmate,
            SpecialMoves::EnableEnPassant => SpecialMoves::EnableEnPassantCheckmate,
            _ => unimplemented!("Checkmate variant not handled for {:?}", self),
        }
    }
    fn add_stalemate(self) -> SpecialMoves {
        match self {
            SpecialMoves::None => SpecialMoves::Stalemate,
            SpecialMoves::Castling => SpecialMoves::CastlingStalemate,
            SpecialMoves::Promotion => SpecialMoves::PromotionStalemate,
            SpecialMoves::CapturePromotion => SpecialMoves::CapturePromotionStalemate,
            SpecialMoves::EnPassant => SpecialMoves::EnPassantStalemate,
            SpecialMoves::EnableEnPassant => SpecialMoves::EnableEnPassantStalemate,
            _ => unimplemented!("Stalemate variant not handled for {:?}", self),
        }
    }
}
