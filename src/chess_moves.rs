use std::fmt;
use std::fmt::Display;
use std::ops::Add;
use crate::rules;
use rules::MoveResult;
use rules::CastleType;

use crate::board::{pieces, Square, SquareExt, Board};
use pieces::Piece;
use crate::board::pieces::Color;
use crate::rules::MoveType;

#[repr(u8)]
#[derive(Debug)]
pub enum MoveData {
    Normal,
    NormalCheck,
    NormaCheckmate,
    NormalStalemate,
    Castling,
    CastlingCheck,
    CastlingCheckmate,
    CastlingStalemate,
    Promotion,
    PromotionCheck,
    PromotionCheckmate,
    PromotionStalemate,
    EnPassant,
    EnPassantCheck,
    EnPassantCheckmate,
    EnPassantStalemate,
    EnableEnPassant,
    EnableEnPassantCheck,
    EnableEnPassantCheckmate,
    EnableEnPassantStalemate,
    Capture,
    CaptureCheck,
    CaptureCheckmate,
    CaptureStalemate,
    CapturePromotion,
    CapturePromotionCheck,
    CapturePromotionCheckmate,
    CapturePromotionStalemate,
    //Moves may be generated by the engine ahead of time, so they may need to be properly classified.
    GeneratedOnly,
}

pub enum SpecialMoveType{
    None,//Has Capture Variant
    Castling,
    Promotion,//Has capture Variant
    EnPassant,//Implicitly captures
    EnableEnPassant,
}

pub enum MoveError{
    CapturedPieceNotProvided,
    LeavesKingInCheck,
    PieceNotFound,
    ObstructedMove
}

#[derive(Debug,)]
pub struct ChessMove {
    piece: Piece,
    origin: Square,
    target: Square,
    special: MoveData,
}

impl ChessMove {
    fn new(piece: Piece, origin: Square, target: Square, special: MoveData) -> ChessMove {
        ChessMove {
            piece,
            origin,
            target,
            special,
        }
    }
    pub fn assemble_special_move(move_type: MoveType, captures: bool, enables_en_passant: bool, result: MoveResult) -> MoveData {
        if enables_en_passant {
            build_move_type(MoveData::EnableEnPassant, result)
        } else {
            match move_type {
                MoveType::Regular => build_none_or_promotion(MoveData::Normal, captures, MoveData::Capture, result),
                MoveType::Castling => build_move_type(MoveData::Castling, result),
                MoveType::EnPassant => build_move_type(MoveData::EnPassant, result),
                MoveType::Promotion => build_none_or_promotion(MoveData::Promotion, captures, MoveData::CapturePromotion, result),
            }
        }
    }

    pub fn to_long_algebraic(&self) -> String {
        let is_promotion = self.special.is_promotion();
        let initial_char:Option<&str> = if is_promotion {None} else {self.piece.to_str()};

        let mut algebraic_notation = if self.special.is_castle() {
            if self.origin.get_col() > self.target.get_col() {
                CastleType::KingSide.to_string()
            } else {
                CastleType::QueenSide.to_string()
            }
        } else {
            format!(
                "{}{}{}{}",
                if initial_char.is_none() { "" } else { initial_char.unwrap() },
                self.origin.to_square_string(),
                if self.special.is_capture() { "x" } else { "-" },
                self.target.to_square_string()
            )
        };

        if is_promotion {
            algebraic_notation.push('=');
            algebraic_notation.push(self.piece.to_char());
        }
        if let Some(move_result) = self.special.move_result().to_char() {
            algebraic_notation.push(move_result)
        }
        algebraic_notation
    }
    pub fn to_simplified(&self) -> String {
        //@TODO give own logic
        return self.to_long_algebraic();
    }

    pub fn make_move(&self, board: &mut Board) {
        match self.special {
            MoveData::Normal | MoveData::EnableEnPassant => {
                board.remove_piece_at(self.origin, self.piece);
                board.add_piece_at(self.target, self.piece);
            }
            _ => unimplemented!()
        }
    }

    fn make_reversible_move(&self, board: &mut Board) -> Option<Piece> {
        //@TODO implement binary splicer for special to extract capture
        /*
        unsafe {

        }
         */
        if self.special.is_capture(){
            if self.special.is_en_passant(){
                self.make_move(board);
                Some(board.active_player.toggle_color().get_pawn())
            } else {
                let captured_piece = board.get_piece_at(self.target);
                self.make_move(board);
                return captured_piece;
            }
        } else {
            self.make_move(board);
            None
        }
    }

    fn undo_move(&self, mut board: &mut Board, removed_piece: Option<Piece>) -> Result<(),MoveError>{
        //@TODO finish implementing
        match self.special {
            MoveData::Normal | MoveData::EnableEnPassant => {
                board.remove_piece_at(self.target, self.piece);
                board.add_piece_at(self.origin, self.piece);
                Ok(())
            }
            _ => unimplemented!()
        }
    }
    
    pub fn leaves_king_in_check(&self, board: &mut Board) -> bool {
        //@TODO implement
        let removed_piece = self.make_reversible_move(board);

        //@TODO Check if king is in check.

        let _ = self.undo_move(board, removed_piece);

        false
    }
    pub fn get_valid_moves(board: &mut Board) -> Vec<ChessMove> {
        let possible_moves: Vec<ChessMove> = Self::get_possible_moves(board);
        Self::validate_moves(possible_moves, board)
    }
    fn validate_moves(moves: Vec<ChessMove>, board: &mut Board) -> Vec<ChessMove> {
        moves.into_iter()
            .filter(|m| !m.leaves_king_in_check(board))
            .collect()
    }
    fn get_possible_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];
        for piece in Piece::iter_color_pieces(&board.active_player){
            match piece {
                Piece::WhitePawn | Piece::BlackPawn=> moves.extend(ChessMove::get_pawn_moves(&board)),
                Piece::WhiteRook | Piece::BlackRook=> moves.extend(ChessMove::get_rook_moves(&board)),
                Piece::WhiteKnight | Piece::BlackKnight=> moves.extend(ChessMove::get_knight_moves(&board)),
                Piece::WhiteBishop | Piece::BlackBishop=> moves.extend(ChessMove::get_bishop_moves(&board)),
                Piece::WhiteQueen | Piece::BlackQueen=> moves.extend(ChessMove::get_queen_moves(&board)),
                Piece::WhiteKing | Piece::BlackKing=> moves.extend(ChessMove::get_king_moves(&board)),
                _ => !unreachable!(),
            }
        }
        moves
    }
    fn get_pawn_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = Vec::new();
        let active_player = &board.active_player;
        let pawn = active_player.get_pawn();
        let pawn_row_ascending = active_player.is_pawn_ascending();
        let starting_row = active_player.get_pawn_starting_row();
        let promotion_row = active_player.get_pawn_promotion_row();
        let mut bitboard = board.get_bitboard(pawn);

        while(bitboard != 0){
            let origin_square:Square = bitboard.trailing_zeros() as Square;
            let col = origin_square.get_col();
            let target_square:Square = if pawn_row_ascending {origin_square + 8} else {origin_square - 8};
            let promotes = target_square.get_row() == promotion_row;
            bitboard &= !(1<<origin_square);

            //Add regular forward move
            if !board.is_piece_at(target_square) {
                if promotes {
                    for promotion_piece in active_player.get_promotion_pieces().iter() {
                        moves.push(ChessMove::new(*promotion_piece, origin_square, target_square, MoveData::Promotion))
                    }
                } else {
                    moves.push(ChessMove::new(pawn, origin_square, target_square, MoveData::Normal));

                    //If regular move is valid, double move may be valid
                    if origin_square.get_row() == starting_row {
                        let target_square: Square = if pawn_row_ascending {origin_square + 16} else {origin_square - 16};
                        if !board.is_piece_at(target_square) {
                            moves.push(ChessMove::new(pawn, origin_square, target_square, MoveData::EnableEnPassant));
                        }
                    }
                }
            }

            fn diagonal_capture(board: &Board, moves: &mut Vec<ChessMove>, pawn: Piece, origin_square: Square,diagonal_target_square: Square, active_player: &Color, promotes: bool){
                // Regular capture
                if board.is_piece_at(diagonal_target_square) {
                    if let Some(_) = board.get_colored_piece_at(diagonal_target_square, active_player.toggle_color()){
                        if promotes {
                            for promotion_piece in active_player.get_promotion_pieces().iter() {
                                moves.push(ChessMove::new(*promotion_piece, origin_square, diagonal_target_square, MoveData::CapturePromotion));
                            }
                        } else {
                            moves.push(ChessMove::new(pawn, origin_square, diagonal_target_square, MoveData::Capture));
                        }
                    }
                // en passant
                } else if board.en_passant_square == Some(diagonal_target_square) {
                    moves.push(ChessMove::new(pawn, origin_square, diagonal_target_square, MoveData::EnPassant));
                }
            }
            //Diagonal left Captures
            if col > 0 {
                let target_square:Square = target_square - 1;
                diagonal_capture(&board, &mut moves, pawn, origin_square, target_square, active_player, promotes);
            }

            //Diagonal right Captures
            if col < 7 {
                let target_square:Square = target_square + 1;
                diagonal_capture(&board, &mut moves, pawn, origin_square, target_square, active_player, promotes);
            }
        }
        moves
    }
    fn get_rook_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_knight_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_bishop_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_queen_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_king_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }

    pub fn debug_string(&self) -> String {
        format!("{} {}", self.to_long_algebraic(), self.special.to_string())
    }
}

impl fmt::Display for ChessMove {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.debug_string().fmt(f)
    }
}

pub fn special_move_builder(move_type: SpecialMoveType, result: MoveResult, captures: bool) -> MoveData {
    match move_type {
        SpecialMoveType::None => build_none_or_promotion(MoveData::Normal, captures, MoveData::Capture, result),
        SpecialMoveType::Promotion => build_none_or_promotion(MoveData::Promotion, captures, MoveData::CapturePromotion, result),
        SpecialMoveType::Castling => build_move_type(MoveData::Castling, result),
        SpecialMoveType::EnPassant => build_move_type(MoveData::EnPassant, result), // Captures handled intrinsically
        SpecialMoveType::EnableEnPassant => build_move_type(MoveData::EnableEnPassant, result),
    }
}
/// Builds `Normal`- or promotion-related moves
fn build_none_or_promotion(base: MoveData, captures: bool, capture_base: MoveData, result: MoveResult) -> MoveData {
    match result {
        MoveResult::None => if captures { capture_base } else { base },
        MoveResult::Check => if captures { capture_base.add_check() } else { base.add_check() },
        MoveResult::Checkmate => if captures { capture_base.add_checkmate() } else { base.add_checkmate() },
        MoveResult::Stalemate => if captures { capture_base.add_stalemate() } else { base.add_stalemate() },
    }
}

/// Builds moves for types without implicit captures (e.g. `Castling`, `EnPassant`, `EnableEnPassant`)
fn build_move_type(base: MoveData, result: MoveResult) -> MoveData {
    match result {
        MoveResult::None => base,
        MoveResult::Check => base.add_check(),
        MoveResult::Checkmate => base.add_checkmate(),
        MoveResult::Stalemate => base.add_stalemate(),
    }
}

/// Helper methods for modifying SpecialMoves
impl MoveData {
    pub fn is_castle(&self) -> bool {
        match self {
            MoveData::Castling | MoveData::CastlingCheck | MoveData::CastlingCheckmate |
            MoveData::CastlingStalemate => true,
            _ => false,
        }
    }
    pub fn is_promotion(&self) -> bool {
        match self {
            MoveData::Promotion | MoveData::PromotionCheck | MoveData::PromotionCheckmate |
            MoveData::PromotionStalemate | MoveData::CapturePromotion |
            MoveData::CapturePromotionCheck | MoveData::CapturePromotionCheckmate |
            MoveData::CapturePromotionStalemate=> true,
            _ => false,
        }
    }
    pub fn is_check(&self) -> bool {
        match self {
            MoveData::NormalCheck | MoveData::CastlingCheck | MoveData::PromotionCheck |
            MoveData::CapturePromotionCheck | MoveData::EnPassantCheck |
            MoveData::EnableEnPassantCheck => true,
            _ => false,
        }
    }
    pub fn is_checkmate(&self) -> bool {
        match self {
            MoveData::NormaCheckmate | MoveData::CastlingCheckmate | MoveData::PromotionCheckmate |
            MoveData::CapturePromotionCheckmate | MoveData::EnPassantCheckmate |
            MoveData::EnableEnPassantCheckmate => true,
            _ => false,
        }
    }
    pub fn is_stalemate(&self) -> bool {
        match self {
            MoveData::NormalStalemate | MoveData::CastlingStalemate | MoveData::PromotionStalemate |
            MoveData::CapturePromotionStalemate | MoveData::EnPassantStalemate |
            MoveData::EnableEnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_capture(&self) -> bool {
        match self {
            MoveData::Capture | MoveData::CaptureCheck | MoveData::CaptureCheckmate |
            MoveData::CapturePromotion | MoveData::CapturePromotionCheck |
            MoveData::CapturePromotionCheckmate | MoveData::EnPassant | MoveData::EnPassantCheck |
            MoveData::EnPassantCheckmate | MoveData::EnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_en_passant(&self) -> bool {
        match self {
            MoveData::EnPassant | MoveData::EnPassantCheck | MoveData::EnPassantCheckmate |
            MoveData::EnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_enable_en_passant(&self) -> bool {
        match self {
            MoveData::EnableEnPassant | MoveData::EnableEnPassantCheck |
            MoveData::EnableEnPassantCheckmate | MoveData::EnableEnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn move_result(&self) -> MoveResult {
        match self {
            MoveData::Normal | MoveData::Castling | MoveData::Promotion |
            MoveData::EnPassant | MoveData::EnableEnPassant |
            MoveData::Capture | MoveData::CapturePromotion =>
                MoveResult::None,
            MoveData::NormalCheck | MoveData::CastlingCheck | MoveData::PromotionCheck |
            MoveData::EnPassantCheck | MoveData::EnableEnPassantCheck |
            MoveData::CaptureCheck | MoveData::CapturePromotionCheck =>
                MoveResult::Check,
            MoveData::NormaCheckmate | MoveData::CastlingCheckmate | MoveData::PromotionCheckmate |
            MoveData::EnPassantCheckmate | MoveData::EnableEnPassantCheckmate |
            MoveData::CaptureCheckmate | MoveData::CapturePromotionCheckmate=>
                MoveResult::Checkmate,
            MoveData::NormalStalemate | MoveData::CastlingStalemate | MoveData::PromotionStalemate |
            MoveData::EnPassantStalemate | MoveData::EnableEnPassantStalemate |
            MoveData::CaptureStalemate | MoveData::CapturePromotionStalemate =>
                MoveResult::Stalemate,
            MoveData::GeneratedOnly | _ => unimplemented!("GeneratedOnly variant not handled for {:?}", self),
        }
    }
    fn add_check(self) -> MoveData {
        match self {
            MoveData::Normal => MoveData::NormalCheck,
            MoveData::Castling => MoveData::CastlingCheck,
            MoveData::Promotion => MoveData::PromotionCheck,
            MoveData::CapturePromotion => MoveData::CapturePromotionCheck,
            MoveData::EnPassant => MoveData::EnPassantCheck,
            MoveData::EnableEnPassant => MoveData::EnableEnPassantCheck,
            _ => unimplemented!("Check variant not handled for {:?}", self),
        }
    }
    fn add_checkmate(self) -> MoveData {
        match self {
            MoveData::Normal => MoveData::NormaCheckmate,
            MoveData::Castling => MoveData::CastlingCheckmate,
            MoveData::Promotion => MoveData::PromotionCheckmate,
            MoveData::CapturePromotion => MoveData::CapturePromotionCheckmate,
            MoveData::EnPassant => MoveData::EnPassantCheckmate,
            MoveData::EnableEnPassant => MoveData::EnableEnPassantCheckmate,
            _ => unimplemented!("Checkmate variant not handled for {:?}", self),
        }
    }
    fn add_stalemate(self) -> MoveData {
        match self {
            MoveData::Normal => MoveData::NormalStalemate,
            MoveData::Castling => MoveData::CastlingStalemate,
            MoveData::Promotion => MoveData::PromotionStalemate,
            MoveData::CapturePromotion => MoveData::CapturePromotionStalemate,
            MoveData::EnPassant => MoveData::EnPassantStalemate,
            MoveData::EnableEnPassant => MoveData::EnableEnPassantStalemate,
            _ => unimplemented!("Stalemate variant not handled for {:?}", self),
        }
    }

    fn to_string(&self) -> String {
        match self {
            MoveData::Normal => String::from("Normal"),
            MoveData::NormalCheck => String::from("Check"),
            MoveData::NormaCheckmate => String::from("Checkmate"),
            MoveData::NormalStalemate => String::from("Stalemate"),
            MoveData::Castling => String::from("Castling"),
            MoveData::CastlingCheck => String::from("CastlingCheck"),
            MoveData::CastlingCheckmate => String::from("CastlingCheckmate"),
            MoveData::CastlingStalemate => String::from("CastlingStalemate"),
            MoveData::Promotion => String::from("Promotion"),
            MoveData::PromotionCheck => String::from("PromotionCheck"),
            MoveData::PromotionCheckmate => String::from("PromotionCheckmate"),
            MoveData::PromotionStalemate => String::from("PromotionStalemate"),
            MoveData::EnPassant => String::from("EnPassant"),
            MoveData::EnPassantCheck => String::from("EnPassantCheck"),
            MoveData::EnPassantCheckmate => String::from("EnPassantCheckmate"),
            MoveData::EnPassantStalemate => String::from("EnPassantStalemate"),
            MoveData::EnableEnPassant => String::from("EnableEnPassant"),
            MoveData::EnableEnPassantCheck => String::from("EnableEnPassantCheck"),
            MoveData::EnableEnPassantCheckmate => String::from("EnableEnPassantCheckmate"),
            MoveData::EnableEnPassantStalemate => String::from("EnableEnPassantStalemate"),
            MoveData::Capture => String::from("Capture"),
            MoveData::CaptureCheck => String::from("CaptureCheck"),
            MoveData::CaptureCheckmate => String::from("CaptureCheckmate"),
            MoveData::CaptureStalemate => String::from("CaptureStalemate"),
            MoveData::CapturePromotion => String::from("CapturePromotion"),
            MoveData::CapturePromotionCheck => String::from("CapturePromotionCheck"),
            MoveData::CapturePromotionCheckmate => String::from("CapturePromotionCheckmate"),
            MoveData::CapturePromotionStalemate => String::from("CapturePromotionStalemate"),
            //Moves may be generated by the engine ahead of time, so they may need to be properly classified.
            MoveData::GeneratedOnly => String::from("GeneratedOnly"),
        }
    }
}