use crate::rules;
use rules::MoveResult;
use rules::CastleType;

use crate::board::{pieces, Square, SquareExt, Board};
use pieces::Piece;
use crate::board::pieces::Color;
use crate::rules::MoveType;

#[repr(u8)]
#[derive(Debug)]
pub enum MoveData {
    Normal,
    NormalCheck,
    NormaCheckmate,
    NormalStalemate,
    Castling,
    CastlingCheck,
    CastlingCheckmate,
    CastlingStalemate,
    Promotion,
    PromotionCheck,
    PromotionCheckmate,
    PromotionStalemate,
    EnPassant,
    EnPassantCheck,
    EnPassantCheckmate,
    EnPassantStalemate,
    EnableEnPassant,
    EnableEnPassantCheck,
    EnableEnPassantCheckmate,
    EnableEnPassantStalemate,
    Capture,
    CaptureCheck,
    CaptureCheckmate,
    CaptureStalemate,
    CapturePromotion,
    CapturePromotionCheck,
    CapturePromotionCheckmate,
    CapturePromotionStalemate,
    //Moves may be generated by the engine ahead of time, so they may need to be properly classified.
    GeneratedOnly,
}

pub enum SpecialMoveType{
    None,//Has Capture Variant
    Castling,
    Promotion,//Has capture Variant
    EnPassant,//Implicitly captures
    EnableEnPassant,
}

#[derive(Debug)]
pub struct ChessMove {
    piece: Piece,
    origin: Square,
    target: Square,
    special: MoveData,
}

impl ChessMove {
    fn new(piece: Piece, origin: Square, target: Square, special: MoveData) -> ChessMove {
        ChessMove {
            piece,
            origin,
            target,
            special,
        }
    }
    pub fn assemble_special_move(move_type: MoveType, captures: bool, enables_en_passant: bool, result: MoveResult) -> MoveData {
        if enables_en_passant {
            build_move_type(MoveData::EnableEnPassant, result)
        } else {
            match move_type {
                MoveType::Regular => build_none_or_promotion(MoveData::Normal, captures, MoveData::Capture, result),
                MoveType::Castling => build_move_type(MoveData::Castling, result),
                MoveType::EnPassant => build_move_type(MoveData::EnPassant, result),
                MoveType::Promotion => build_none_or_promotion(MoveData::Promotion, captures, MoveData::CapturePromotion, result),
            }
        }
    }

    pub fn to_long_algebraic(&self) -> String {
        let is_promotion = self.special.is_promotion();
        let initial_char:Option<&str> = if is_promotion {None} else {self.piece.to_str()};

        let mut algebraic_notation = if self.special.is_castle() {
            if self.origin.get_col() > self.target.get_col() {
                CastleType::KingSide.to_string()
            } else {
                CastleType::QueenSide.to_string()
            }
        } else {
            format!(
                "{}{}{}{}",
                if initial_char.is_none() { "" } else { initial_char.unwrap() },
                self.origin.to_square_string(),
                if self.special.is_capture() { "x" } else { "-" },
                self.target.to_square_string()
            )
        };

        if is_promotion {
            algebraic_notation.push('=');
            algebraic_notation.push(self.piece.to_char());
        }
        if let Some(move_result) = self.special.move_result().to_char() {
            algebraic_notation.push(move_result)
        }
        algebraic_notation
    }
    pub fn to_simplified(&self) -> String {
        //@TODO give own logic
        return self.to_long_algebraic();
    }

    pub fn get_valid_moves(board: &Board) -> Vec<ChessMove> {
        let possible_moves: Vec<ChessMove> = Self::get_possible_moves(board);
        Self::validate_moves(possible_moves)
    }
    fn validate_moves(moves: Vec<ChessMove>) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_possible_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];
        for piece in Piece::iter_color_pieces(&board.active_player){
            match piece {
                Piece::WhitePawn | Piece::BlackPawn=> moves.extend(ChessMove::get_pawn_moves(&board)),
                Piece::WhiteRook | Piece::BlackRook=> moves.extend(ChessMove::get_rook_moves(&board)),
                Piece::WhiteKnight | Piece::BlackKnight=> moves.extend(ChessMove::get_knight_moves(&board)),
                Piece::WhiteBishop | Piece::BlackBishop=> moves.extend(ChessMove::get_bishop_moves(&board)),
                Piece::WhiteQueen | Piece::BlackQueen=> moves.extend(ChessMove::get_queen_moves(&board)),
                Piece::WhiteKing | Piece::BlackKing=> moves.extend(ChessMove::get_king_moves(&board)),
                _ => !unreachable!(),
            }
        }
        moves
    }
    fn get_pawn_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_rook_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_knight_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_bishop_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_queen_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
    fn get_king_moves(board: &Board) -> Vec<ChessMove> {
        let mut moves: Vec<ChessMove> = vec![];

        moves
    }
}

pub fn special_move_builder(move_type: SpecialMoveType, result: MoveResult, captures: bool) -> MoveData {
    match move_type {
        SpecialMoveType::None => build_none_or_promotion(MoveData::Normal, captures, MoveData::Capture, result),
        SpecialMoveType::Promotion => build_none_or_promotion(MoveData::Promotion, captures, MoveData::CapturePromotion, result),
        SpecialMoveType::Castling => build_move_type(MoveData::Castling, result),
        SpecialMoveType::EnPassant => build_move_type(MoveData::EnPassant, result), // Captures handled intrinsically
        SpecialMoveType::EnableEnPassant => build_move_type(MoveData::EnableEnPassant, result),
    }
}
/// Builds `Normal`- or promotion-related moves
fn build_none_or_promotion(base: MoveData, captures: bool, capture_base: MoveData, result: MoveResult) -> MoveData {
    match result {
        MoveResult::None => if captures { capture_base } else { base },
        MoveResult::Check => if captures { capture_base.add_check() } else { base.add_check() },
        MoveResult::Checkmate => if captures { capture_base.add_checkmate() } else { base.add_checkmate() },
        MoveResult::Stalemate => if captures { capture_base.add_stalemate() } else { base.add_stalemate() },
    }
}

/// Builds moves for types without implicit captures (e.g. `Castling`, `EnPassant`, `EnableEnPassant`)
fn build_move_type(base: MoveData, result: MoveResult) -> MoveData {
    match result {
        MoveResult::None => base,
        MoveResult::Check => base.add_check(),
        MoveResult::Checkmate => base.add_checkmate(),
        MoveResult::Stalemate => base.add_stalemate(),
    }
}

/// Helper methods for modifying SpecialMoves
impl MoveData {
    pub fn is_castle(&self) -> bool {
        match self {
            MoveData::Castling | MoveData::CastlingCheck | MoveData::CastlingCheckmate |
            MoveData::CastlingStalemate => true,
            _ => false,
        }
    }
    pub fn is_promotion(&self) -> bool {
        match self {
            MoveData::Promotion | MoveData::PromotionCheck | MoveData::PromotionCheckmate |
            MoveData::PromotionStalemate | MoveData::CapturePromotion |
            MoveData::CapturePromotionCheck | MoveData::CapturePromotionCheckmate |
            MoveData::CapturePromotionStalemate=> true,
            _ => false,
        }
    }
    pub fn is_check(&self) -> bool {
        match self {
            MoveData::NormalCheck | MoveData::CastlingCheck | MoveData::PromotionCheck |
            MoveData::CapturePromotionCheck | MoveData::EnPassantCheck |
            MoveData::EnableEnPassantCheck => true,
            _ => false,
        }
    }
    pub fn is_checkmate(&self) -> bool {
        match self {
            MoveData::NormaCheckmate | MoveData::CastlingCheckmate | MoveData::PromotionCheckmate |
            MoveData::CapturePromotionCheckmate | MoveData::EnPassantCheckmate |
            MoveData::EnableEnPassantCheckmate => true,
            _ => false,
        }
    }
    pub fn is_stalemate(&self) -> bool {
        match self {
            MoveData::NormalStalemate | MoveData::CastlingStalemate | MoveData::PromotionStalemate |
            MoveData::CapturePromotionStalemate | MoveData::EnPassantStalemate |
            MoveData::EnableEnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_capture(&self) -> bool {
        match self {
            MoveData::Capture | MoveData::CaptureCheck | MoveData::CaptureCheckmate |
            MoveData::CapturePromotion | MoveData::CapturePromotionCheck |
            MoveData::CapturePromotionCheckmate | MoveData::EnPassant | MoveData::EnPassantCheck |
            MoveData::EnPassantCheckmate | MoveData::EnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_en_passant(&self) -> bool {
        match self {
            MoveData::EnPassant | MoveData::EnPassantCheck | MoveData::EnPassantCheckmate |
            MoveData::EnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn is_enable_en_passant(&self) -> bool {
        match self {
            MoveData::EnableEnPassant | MoveData::EnableEnPassantCheck |
            MoveData::EnableEnPassantCheckmate | MoveData::EnableEnPassantStalemate => true,
            _ => false,
        }
    }
    pub fn move_result(&self) -> MoveResult {
        match self {
            MoveData::Normal | MoveData::Castling | MoveData::Promotion |
            MoveData::EnPassant | MoveData::EnableEnPassant |
            MoveData::Capture | MoveData::CapturePromotion =>
                MoveResult::None,
            MoveData::NormalCheck | MoveData::CastlingCheck | MoveData::PromotionCheck |
            MoveData::EnPassantCheck | MoveData::EnableEnPassantCheck |
            MoveData::CaptureCheck | MoveData::CapturePromotionCheck =>
                MoveResult::Check,
            MoveData::NormaCheckmate | MoveData::CastlingCheckmate | MoveData::PromotionCheckmate |
            MoveData::EnPassantCheckmate | MoveData::EnableEnPassantCheckmate |
            MoveData::CaptureCheckmate | MoveData::CapturePromotionCheckmate=>
                MoveResult::Checkmate,
            MoveData::NormalStalemate | MoveData::CastlingStalemate | MoveData::PromotionStalemate |
            MoveData::EnPassantStalemate | MoveData::EnableEnPassantStalemate |
            MoveData::CaptureStalemate | MoveData::CapturePromotionStalemate =>
                MoveResult::Stalemate,
            MoveData::GeneratedOnly => unimplemented!("GeneratedOnly variant not handled for {:?}", self),
        }
    }
    fn add_check(self) -> MoveData {
        match self {
            MoveData::Normal => MoveData::NormalCheck,
            MoveData::Castling => MoveData::CastlingCheck,
            MoveData::Promotion => MoveData::PromotionCheck,
            MoveData::CapturePromotion => MoveData::CapturePromotionCheck,
            MoveData::EnPassant => MoveData::EnPassantCheck,
            MoveData::EnableEnPassant => MoveData::EnableEnPassantCheck,
            _ => unimplemented!("Check variant not handled for {:?}", self),
        }
    }
    fn add_checkmate(self) -> MoveData {
        match self {
            MoveData::Normal => MoveData::NormaCheckmate,
            MoveData::Castling => MoveData::CastlingCheckmate,
            MoveData::Promotion => MoveData::PromotionCheckmate,
            MoveData::CapturePromotion => MoveData::CapturePromotionCheckmate,
            MoveData::EnPassant => MoveData::EnPassantCheckmate,
            MoveData::EnableEnPassant => MoveData::EnableEnPassantCheckmate,
            _ => unimplemented!("Checkmate variant not handled for {:?}", self),
        }
    }
    fn add_stalemate(self) -> MoveData {
        match self {
            MoveData::Normal => MoveData::NormalStalemate,
            MoveData::Castling => MoveData::CastlingStalemate,
            MoveData::Promotion => MoveData::PromotionStalemate,
            MoveData::CapturePromotion => MoveData::CapturePromotionStalemate,
            MoveData::EnPassant => MoveData::EnPassantStalemate,
            MoveData::EnableEnPassant => MoveData::EnableEnPassantStalemate,
            _ => unimplemented!("Stalemate variant not handled for {:?}", self),
        }
    }
}
